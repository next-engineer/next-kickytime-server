name: EC2 - Deploy (dispatch)

on:
  repository_dispatch:
    types: [deploy-ec2]
  workflow_dispatch:

concurrency:
  group: ec2-deploy
  cancel-in-progress: false

permissions:
  contents: read

env:
  AWS_REGION: ap-northeast-2
  # âœ… ë°°í¬ ëŒ€ìƒ EC2 ë¦¬ìŠ¤íŠ¸(JSON ë°°ì—´). í•„ìš”ì— ë§ê²Œ êµì²´í•˜ì„¸ìš”.
  INSTANCE_IDS_JSON: '["i-08f17d18d83292c07","i-08316767f2bd4a5ed"]'

  # âœ… ì•±/ì»¨í…Œì´ë„ˆ ì„¤ì •
  APP_NAME: kickytime            # ê¸°ì¡´ ì»¨í…Œì´ë„ˆ ê¸°ë³¸ ì´ë¦„ (ì˜ˆ: kickytime)
  CONTAINER_PORT: "8080"         # ì»¨í…Œì´ë„ˆ ë‚´ë¶€ í¬íŠ¸
  HOST_PORT_BASE: "8080"         # ê¸°ì¡´ ì»¨í…Œì´ë„ˆê°€ ë°”ì¸ë“œí•˜ëŠ” í˜¸ìŠ¤íŠ¸ í¬íŠ¸
  HEALTH_PATH: "/actuator/health" # í—¬ìŠ¤ì²´í¬ ê²½ë¡œ
  HEALTH_TIMEOUT_SEC: "180"      # í—¬ìŠ¤ì²´í¬ ìµœëŒ€ ëŒ€ê¸°ì‹œê°„
  ENV_FILE_PATH: ""              # ì˜ˆ: /opt/kickytime/.env (ì—†ìœ¼ë©´ ë¹ˆ ê°’)

jobs:
  deploy:
    runs-on: ubuntu-latest
    strategy:
      max-parallel: 1
      matrix:
        instance_id: ${{ fromJson(env.INSTANCE_IDS_JSON) }}

    env:
      PAYLOAD_IMAGE_URI: ${{ github.event.client_payload.image_uri }}
      PAYLOAD_TAG:       ${{ github.event.client_payload.tag }}
      PAYLOAD_BRANCH:    ${{ github.event.client_payload.branch }}
      PAYLOAD_SHA:       ${{ github.event.client_payload.sha }}

    steps:
      - name: Gate - only deploy for main
        id: gate
        run: |
          if [ "${PAYLOAD_BRANCH}" = "main" ]; then
            echo "GO=true" >> $GITHUB_OUTPUT
          else
            echo "GO=false" >> $GITHUB_OUTPUT
            echo "Non-deploy branch: ${PAYLOAD_BRANCH}"
          fi

      - name: Checkout (same commit as build)
        if: steps.gate.outputs.GO == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ env.PAYLOAD_SHA }}

      - name: Configure AWS credentials
        if: steps.gate.outputs.GO == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Send rolling deploy command via SSM
        if: steps.gate.outputs.GO == 'true'
        id: ssm
        run: |
          set -e

          TARGET_ID="${{ matrix.instance_id }}"
          echo "Deploying to instance: $TARGET_ID"
          
          # ìƒˆ ì»¨í…Œì´ë„ˆê°€ ë°”ì¸ë“œí•  ì„ì‹œ í¬íŠ¸(í˜„ì¬ HOST_PORT_BASE+1)
          NEXT_PORT=$(( ${HOST_PORT_BASE} + 1 ))

          # SSMì— ë³´ë‚¼ ìŠ¤í¬ë¦½íŠ¸ë¥¼ JSON ì•ˆì „í•˜ê²Œ ë³€í™˜
          read -r -d '' SCRIPT <<'EOSCRIPT'
          #!/usr/bin/env bash
          set -euo pipefail

          APP_NAME="${APP_NAME}"
          IMAGE_URI="${PAYLOAD_IMAGE_URI}"
          CONTAINER_PORT="${CONTAINER_PORT}"
          HOST_PORT_BASE="${HOST_PORT_BASE}"
          NEXT_PORT=$(( HOST_PORT_BASE + 1 ))
          HEALTH_PATH="${HEALTH_PATH}"
          HEALTH_TIMEOUT="${HEALTH_TIMEOUT_SEC}"
          ENV_FILE_PATH="${ENV_FILE_PATH}"

          OLD_NAME="${APP_NAME}"
          NEW_NAME="${APP_NAME}_new"

          echo "[1/7] ECR ë¡œê·¸ì¸"
          REGISTRY_HOST="$(echo "$IMAGE_URI" | awk -F'/' '{print $1}')"
          aws ecr get-login-password --region "${AWS_REGION}" | docker login --username AWS --password-stdin "${REGISTRY_HOST}"

          echo "[2/7] ìƒˆ ì´ë¯¸ì§€ Pull: ${IMAGE_URI}"
          docker pull "${IMAGE_URI}"

          echo "[3/7] ì´ì „ NEW ì»¨í…Œì´ë„ˆ ì •ë¦¬(ìˆìœ¼ë©´)"
          if docker ps -a --format '{{.Names}}' | grep -q "^${NEW_NAME}$"; then
            docker rm -f "${NEW_NAME}" || true
          fi

          echo "[4/7] ìƒˆ ì»¨í…Œì´ë„ˆ ê¸°ë™: ${NEW_NAME} (host ${NEXT_PORT} -> container ${CONTAINER_PORT})"
          RUN_ENV_OPTS=()
          if [ -n "${ENV_FILE_PATH}" ]; then
            RUN_ENV_OPTS+=( --env-file "${ENV_FILE_PATH}" )
          fi

          docker run -d \
            --name "${NEW_NAME}" \
            -p "${NEXT_PORT}:${CONTAINER_PORT}" \
            "${RUN_ENV_OPTS[@]}" \
            "${IMAGE_URI}"

          echo "[5/7] í—¬ìŠ¤ì²´í¬: http://127.0.0.1:${NEXT_PORT}${HEALTH_PATH} (timeout: ${HEALTH_TIMEOUT}s)"
          SECS=0
          until curl -fsS "http://127.0.0.1:${NEXT_PORT}${HEALTH_PATH}" >/dev/null 2>&1; do
            sleep 3
            SECS=$(( SECS + 3 ))
            if [ "${SECS}" -ge "${HEALTH_TIMEOUT}" ]; then
              echo "âŒ ìƒˆ ì»¨í…Œì´ë„ˆ í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨. ë¡œê·¸:"
              docker logs --tail 200 "${NEW_NAME}" || true
              exit 1
            fi
          done
          echo "âœ… ìƒˆ ì»¨í…Œì´ë„ˆ Healthy"

          echo "[6/7] ê¸°ì¡´ ì»¨í…Œì´ë„ˆ ${OLD_NAME} ì¢…ë£Œ/ì‚­ì œ ë° í¬íŠ¸ ìŠ¤ìœ„ì¹­"
          if docker ps -a --format '{{.Names}}' | grep -q "^${OLD_NAME}$"; then
            docker rm -f "${OLD_NAME}" || true
          fi

          # ìƒˆ ì»¨í…Œì´ë„ˆë¥¼ ê¸°ë³¸ ì´ë¦„ìœ¼ë¡œ ìŠ¹ê²©
          docker rename "${NEW_NAME}" "${OLD_NAME}"

          echo "[7/7] ì²­ì†Œ (Dangling Images/Containers)"
          docker system prune -f || true

          echo "ğŸ‰ ë¡¤ë§ ì™„ë£Œ: $(docker ps --filter "name=${OLD_NAME}" --format 'table {{.Names}}\t{{.Image}}\t{{.Ports}}')"
          EOSCRIPT

          # jqë¡œ ì´ìŠ¤ì¼€ì´í”„í•˜ì—¬ commandsì— ë„£ê¸°
          JSON_SCRIPT=$(jq -Rn --arg s "$SCRIPT" '$s')

          CMD_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --instance-ids "$TARGET_ID" \
            --parameters commands="[$JSON_SCRIPT]" \
            --comment "Rolling deploy ${APP_NAME} -> ${PAYLOAD_IMAGE_URI}" \
            --timeout-seconds 1800 \
            --query "Command.CommandId" \
            --output text)

          echo "SSM CommandId: ${CMD_ID}"
          aws ssm wait command-executed --command-id "$CMD_ID" --instance-id "$TARGET_ID"
          
          # ì‹¤íŒ¨ ì‹œ ë¡œê·¸ ì¶œë ¥
          STATUS=$(aws ssm list-command-invocations --command-id "$CMD_ID" --instance-id "$TARGET_ID" --details \
                   --query "CommandInvocations[0].Status" --output text)
          echo "SSM Status: $STATUS"
          if [ "$STATUS" != "Success" ]; then
            echo "---- SSM Output ----"
            aws ssm list-command-invocations --command-id "$CMD_ID" --instance-id "$TARGET_ID" --details \
              --query "CommandInvocations[0].CommandPlugins[0].{StdOut:Output,StdErr:StandardErrorContent}" --output json
            exit 1
          fi

      - name: Summary
        if: steps.gate.outputs.GO == 'true'
        run: |
          echo "### âœ… EC2 Rolling Deploy Completed" >> $GITHUB_STEP_SUMMARY
          echo "- Instance: \`${{ matrix.instance_id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Image:    \`${PAYLOAD_IMAGE_URI}\`"     >> $GITHUB_STEP_SUMMARY
          echo "- Branch:   \`${PAYLOAD_BRANCH}\`"        >> $GITHUB_STEP_SUMMARY
          echo "- Commit:   \`${PAYLOAD_SHA}\`"           >> $GITHUB_STEP_SUMMARY
